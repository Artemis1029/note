时间片的测量：
#include <iostream>
using std::cout; using std::endl;
#include <windows.h>
int main(void) {
	SYSTEMTIME systime;
	long temp =0, sub=0;
	long ptime =0,ntime =0;
	
	for(long i1=0; i1 < 1e8; ++i1) {
		GetLocalTime(&systime);
		if(systime.wMilliseconds -temp>1) { //这里大于1有问题
			ntime =systime.wMilliseconds;
			if(ntime-ptime < 0 )
				cout << ntime +1000-ptime << endl;
			else
				cout << ntime -ptime << endl;
			ptime =ntime;
		}		
		temp=systime.wMilliseconds;
	}
	return 0;
}
上面是学长的代码，出现一点问题，主要这个代码的测试效果不是很灵，但是大部分数据时正确的，得到了时间片是15这个结果。偶尔会出现几个很大的数字，经过判断是因为那句大于1的if判断，进程因为时间片到而离开到之后立即装入所需要的时间大部分是0-2毫秒（要么0要么1要么2，其实主要应该是个接近1的小数，C++做不到再精确了，一旦出现1，那么得到的测量就是几个时间片的时间和）
要知道装入时间（时间片与时间片之间时间）直接：
for(long i1=0; i1 < 1e8; ++i1) {
		GetLocalTime(&systime);
		if(systime.wMilliseconds -temp>0) { //这里大于1有问题
			cout << systime.wMilliseconds -temp <<endl;
		}		
		temp=systime.wMilliseconds;
}



#include <iostream>
using std::cout; using std::endl;
#include <ctime>
int main(void) {
	clock_t begin,end;
	
	while(1) {
		int i1 =0;
		begin =clock();
		for(int i2=0;i2 < i1; ++i2)
			1+2+3;
		end =clock();
		if(end -begin != 0)
			cout << end-begin << ' ' << i1 << endl;
		else
			++i1;
	}
	
	return 0;
}
这是我的代码，还好好奇看了下i1的值才发现有隐匿的神奇。本来以为程序会单独占用一个核心，如果因为时间片到了被T出来，之后也会马上进去，这样的话测量任务就是需找一个i来制作一个占用时间接近时间片长度的for循环。其实这个想法对不上这个程序，因为程序调用中断来进行输出的时候时间片。臆想中i的值应该差不多1e6以上。但是看输出，你会发现i的值很怪异，从小到大增大。后来想通了，是因为本进程时间片用完以后，这个核心下一个时间片并不一定就会给本进程。



#include <iostream>
using std::cout; using std::endl;
#include <ctime>
int main(void) {
	clock_t begin,end;
	
	while(1) {
		int i1 =0;
		begin =clock();
		end =clock();
		if(end -begin != 0)
			cout << end-begin  << endl;
		else
			continue;
	}
	
	return 0;
}
考虑到装入时间零点几毫秒，所以最后还要人工减一下。


#include <iostream>
using std::cout; using std::endl;
#include <windows.h>
int main(void) {
	SYSTEMTIME systime;
	int begin,end;
	int i =0;
	while(1) {
		GetLocalTime(&systime);
		begin =systime.wMilliseconds;
		GetLocalTime(&systime);
		end =systime.wMilliseconds;
		if(end -begin > 0) i++;
		if(i > 10) break;
	}
	
	return 0;
}
这段代码排除了因为要输出而使得下一个时间片被分给其他进程这一个猜测，其实不管数不输出下一个时间片都不一定给自己。



深度操作系统：一个适合一般用户，桌面美化等做得很好但是装软件蛋疼，依赖被阉割
深度在2014年之前，自己做了一个WebKit/Html5的本地渲染引擎，可以直接用CoffeeScript像网页开发一样来编写桌面环境的界面，但是最后因为WebKit对于常驻性的桌面环境进程来并不适合，长时间不关机非常容易引起内存泄露和性能问题。包括2014年之前，采用的Python/QML来开发的应用都全部由 QtWidget/C++ 替换掉，主要是因为Python在国产CPU平台（龙芯、申威）上运行很慢，QML的解释特性和默认OpenGL渲染的机制都导致软件实际运行的性能不好。

深度这么多年几乎把所有的界面编程语言（Python、C、C++、CoffeeScript/JS、Golang）和几乎所有的图形界面库（wx、GTK+、Qt、WebKit、QML）都折腾过了。
最后停留在 Golang、C++、QtWidget 的技术选型上，因为这些技术不论从稳定性、兼容性还是性能都非常好。

桌面：
    RedHat主导开发的Gnome, Gnome2的稳定性和性能都非常好，包括后面的Mint桌面都是衍生于Gnome2, Gnome3是我作为个人开发者来看最失望的桌面环境，Gnome3完全抛弃了Gnome2的稳定和性能，Gnome3除了性能和内存控制不好以外，API的胡乱修改导致这5年几乎没有任何重大的进步
    Suse主导开发的KDE：可以说功能最为丰富的桌面环境，包括产品质量以及性能每年都在飞速进步，但从个人看比较适合技术折腾党，功能和交互做的太复杂不适合普通用户（比如那个超级复杂的主题设置）
    Ubuntu主导开发的Unity: Unity身上还是可以看到很多Gnome2的影子，产品质量和性能都不错，Ubuntu自己独立开发了Mir、Unity桌面环境和一些全局菜单等独特特性，虽然很多开发者很喜欢，但是整体视觉都聚焦在左上角（默认看着很想一把转角直尺）的设计，个人觉得并不符合中国人的使用习惯
    Deepin主导开发的DDE: 作为DDE的开发者，客观的评价，产品质量、设计视觉都符合中国人的习惯，很多地方的交互设计细节要比其他桌面环境做的更加精致和简单，主要面向开箱即用的非技术型用户，从功能设计上并不适合技术高手和那些本来就喜欢折腾的技术型用户
    轻量级的xcfe。
其他轻量型的桌面环境，比如LXDE、XFCE、Enlightenment虽然性能极佳，但是从桌面环境的功能完整性和交互设计的精致性上都不够，比较适合有一定技术深度，追求性能和自己配置多于开箱即用的技术型用户
内核、驱动以及固件：主要用于驱动硬件可以正常工作，除了CPU、内存、磁盘外，最主要的要是要广泛兼容不同的网卡、显卡、声卡和外设等硬件设备

桌面环境的技术核心全部都依赖一批古老的协议，比如:x11、xcb、composite等基础技术，互联网上几乎没有文档教你怎么一步一步的构建桌面环境，现成的桌面环境因为发展多年，代码已经非常复杂，最多只能从核心代码片段有所学习。一个人要自上而下框架式的学习桌面环境核心技术并实现一套功能完备的桌面环境几乎不可能。
所以，大部分的Linux发行版都是基于Gnome、KDE改的，大多数都是在网上找一批主题（Gtk+主题、图标主题、光标主题、窗口边框主题、DM主题、锁屏主题）再配上一张好看的壁纸就可以做一套自己DIY的桌面环境。很多Linux社区的用户说，你看我自己都可以做桌面环境，甚至很多国内的Linux发行版厂商也是拿着社区的桌面环境然后换一套皮肤就去骗政府的钱，说自己是自主研发的操作系统（很可悲，这个世界上骗子永远比正直的人多）。

很多按钮的颜色、留白以及控件的对齐都是有问题的，甚至是粗糙的，为什么？这是由GTK+的主题设计导致的，GTK+强调的是一套原生控件打天下，但是面对无穷的应用和需求，不是所有的交互都能靠一套控件才能满足的，在大多数Linux社区开发者不具备控件自绘的能力前提下，大多数开发者都选择套用不合适的控件和控件主题去拼装，而GTK+主题的作者不可能在制作主题的时候测试所有软件，而且从GTK+先天限制也做不到，最后导致不论怎么套用主题，各种软件拼装在一起，就像各种质量参差不齐的补丁拼在一起一样的


一个完整的桌面系统从技术剖面看，从下到上主要分这几层：
    内核驱动层：前面已经说了，主要是保障硬件的基本功能和兼容性，所有的Linux发行版都大同小异，差别就是内核补丁集不一样，或者集成的驱动和固件多少的差异
    显示服务层：从内核引导到plymouth(我们俗称的开机动画）后，只要你见到登录界面输入密码的时候，这时候X Server已经起来了， X Server简单来理解就是Linux系统中掌握着绘制图形界面生杀大权的“天神”，所有程序要绘制图形的时候都要发送消息到 X Server, X Server才会给你画出来。同时X Server也是事件输入（键盘鼠标）输出（显示器）的抽象层，开发者可以不用考虑底层驱动和显卡驱动细节，直接就可以使用X11/XCB的API进行应用开发，只不过更多的开发者是使用Gtk+/Qt这些在X11/XCB更上层的API进行应用开发
    显示管理器：简单的理解就是你看到的登录界面提示你输入密码的那个地方
    资源管理器：这一层主要由一系列的底层守护程序来监控硬件的状态，并汇报给上层的桌面环境和应用进一步操作，比如常见的就有网络、电源、磁盘、蓝牙、声音、键盘、打印等
    桌面环境： 以深度桌面环境为例，主要包括桌面环境后台服务和守护进程、桌面环境对外提供图形开发工具库、二进制工具、DBus API服务和桌面环境UI界面层几个部分组成的，后面我会详细讲每一个细节
    应用商店：主要提供系统的软件安装、卸载、升级等操作，保证用户可以安全易用的进行软件管理，同时提供了商店的评论和评分等功能
    应用程序：主要包括深度开发的系列应用、合作开发的国内应用、Android应用、Windows应用和网页应用，为什么在Linux可以直接运行Android和Windows应用？ 我也后面再讲，嘿嘿
显示服务层X Server启动-》显示管理器启动（深度操作系统使用的是Ubuntu开发的LightDOM）

deepin-wine 支持50+多款Windows应用，通过内置 Android runtime支持200+多款Android应用（比如愤怒小鸟，各种视频客户端），通过和Intel合作开发 deepin-xwalk 直接支持html5应用（比如Gliffy等）还可以自己记住窗口大小（而不是打开一个贼大的浏览器）

深度开源字体
    社区中吵了十几年的Office排版字体，要不就是吐槽，要不就是拷贝微软版权字体，没有人站出来解决问题。5个版权字体，上千个符号，我们一个一个字体，自己重新画了一遍，然后开源给大家免费使用，行动才能推动开源，而不是靠嘴




1、连续分配方式
连续分配方式：为一个用户程序分配一个连续的内存空间。
连续分配方式进一步分为：单一连续分配、固定分区分配、动态分区分配以及动态重定位分区分配。
2、单一连续分配
最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。
采用这种存储管理方式时，可把内存分为系统区和用户区两部分，系统区仅提供给OS使用，通常是放在内存的低址部分；
用户区是指除系统区以外的全部内存空间，提供给用户使用。
在早期的单用户、单任务操作系统中，有不少都配置了存储器保护机构，用于防止用户程序对操作系统的破坏。但在近年来常见的单用户操作系统中，
都未采取存储器保护措施。一方面可以节省硬件，另一方面因为这是可行的。
在单用户环境下，机器由一用户独占，不可能存在其他用户干扰的问题，这时可能出现的破坏行为也只是用户程序自己去破坏操作系统，其后果并不
严重，只是会影响该用户程序的运行，且操作系统也很容易通过系统的再次启动而重新装入内存。

LRU是最近最少使用页面置换算法(Least Recently Used),也就是首先淘汰最长时间未被使用的页面!
LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页!

操作系统控制文件的删除就像是智能指针一样，一旦引用没有了就会删除，所以在文件结构中存在对引用的计数。文件的存储实际上就是名字到存储结构体最后再到实际存储硬盘块就好。


堆文件是最简单的文件结构。一个堆文件中的数据在文件页中以任意的顺序排列。
堆文件的格式是libpcap的一种。这种格式中，包含了被捕捉到的包的二进制数据，并且，这种格式是许多网络工具所使用的一种标准，这些工具包括WinDump，Etheral和Snort。THE PILE: Least complicated form of file organization. Data are collected in the order they arrive. Each record consist of one burst of data.Purpose is simply to accumalate the mass of data and save it. Record access is by exhaustive search. 


操作系统可以不要内核，后果就是你玩游戏的时候就不能开迅雷了。内核的一个作用就是实现任务调度，让计算机的资源都被均衡的调度。没有内核的后果就是不能同时处理多个任务。






biolinux 就是 ubuntu。 配套安装了一系列生物信息学的软件而已。 
