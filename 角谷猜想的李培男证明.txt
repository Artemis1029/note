101111
1000111       3   3


1101011
10100001
1111001
1011011
10001001
1100111
10011011
11101001
10101111
100000111     5   3


110001011
1001010001
110111101
10100111
11111011
101111001
100011011
110101001
100111111     2   6


111011111		
1011001111
10000110111
11001010011
100101111101
1110001111		
10101010111
100000000011  9   2


110000000101
1001000001
110110001
101000101
111101
10111         1   3
100011        3   2
110101
101
1




用二进制去看角谷猜想：
1会被11替代，到达2又进一位<=>1会排斥周围的1，而末尾相连的1们又会一个一个从末尾开始被抛到相连1们最前面的1前进2个单位的位置。所以得到如下结论:
一个大于等于1的自然数，必定可以化为一个二进制数（因为不同的进制只是意味着不同的计数方法）。那么考虑到排斥就有两种可能：①成为101010...1这样于是呢就直接消除了；②前面或者后面或者两遍留下一连串的1，然后另一边就是101010...10。也就是接近①的结果，这种在经过一次就会变成1000..00111...11这样开头一个1中间n个0后面m个1的形式。上面的数据是我对110这个数字进行变换的时候从中间摘录的连续的一堆数据。我想知道为什么100...0011...111可以化短（已经证明一定范围内的数是满足的）或者说化为1。




获取数据使用的代码如下：
#include <stdio.h>

void Fun(int num);

int main()
{
	long input1,input;
	long min,max;
	
	printf("I wish you input min and max:\n");
	scanf("%ld%ld", &min, &max);
	for(input1 =min;input1 <= max;input1++) {
		input =input1;
		printf("%d\n", input);
		while(input%2 == 0)
			input /= 2;
		Fun(input);
		puts("");
		while(input!=1) {
			if(input%2 == 1) {
				input =input*3+1;
				while(input%2 == 0)
					input /= 2;
				Fun(input);
			}else{
				input /= 2;
				continue;
			}
			puts("");
		}
		puts("");puts("");puts("");
		
	}
	// long a;
	// int count;
	
	// scanf("%d", &a);
	// for(count =0;count < 20;count++) {
		// Fun(a);
		// a *=3;
		// puts("");
	// }
		
	return 0;
}

void Fun(int num)
{
	if(num%2 == num)
		printf("%d", num);
	else {
		Fun((num-num%2)/2);
		printf("%d", num%2);
	}
}